
======= @openzeppelin/contracts/token/ERC721/IERC721.sol:IERC721 =======
Developer Documentation
{"details":"Required interface of an ERC721 compliant contract.","events":{"Approval(address,address,uint256)":{"details":"Emitted when `owner` enables `approved` to manage the `tokenId` token."},"ApprovalForAll(address,address,bool)":{"details":"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."},"Transfer(address,address,uint256)":{"details":"Emitted when `tokenId` token is transferred from `from` to `to`."}},"kind":"dev","methods":{"approve(address,uint256)":{"details":"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{"details":"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{"details":"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{"details":"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{"details":"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{"details":"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{"details":"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{"details":"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}},"version":1}
User Documentation
{"kind":"user","methods":{},"version":1}

======= @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol:IERC721Enumerable =======
Developer Documentation
{"details":"See https://eips.ethereum.org/EIPS/eip-721","kind":"dev","methods":{"approve(address,uint256)":{"details":"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{"details":"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{"details":"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{"details":"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{"details":"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{"details":"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{"details":"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenByIndex(uint256)":{"details":"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{"details":"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"totalSupply()":{"details":"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{"details":"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}},"title":"ERC-721 Non-Fungible Token Standard, optional enumeration extension","version":1}
User Documentation
{"kind":"user","methods":{},"version":1}

======= @openzeppelin/contracts/utils/introspection/ERC165.sol:ERC165 =======
Developer Documentation
{"details":"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ``` Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1}
User Documentation
{"kind":"user","methods":{},"version":1}

======= @openzeppelin/contracts/utils/introspection/IERC165.sol:IERC165 =======
Developer Documentation
{"details":"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"version":1}
User Documentation
{"kind":"user","methods":{},"version":1}

======= contracts/Builder.sol:Builder =======
Developer Documentation
{"custom:type":"interface","kind":"dev","methods":{"aGovernance()":{"returns":{"_0":"Builder this contract"}},"build()":{"details":"contructs a new contract and may require a large gas fee, does not reinitialize context","returns":{"_0":"the address of the new Governance contract"}},"name()":{"returns":{"_0":"string memory representation of name"}},"version()":{"returns":{"_0":"uint32 version number"}},"withSupervisor(address)":{"details":"maintains an internal list which increases with every call","params":{"_supervisor":"the address of the wallet representing a supervisor for the project"},"returns":{"_0":"Builder this contract"}},"withVoterClass(address)":{"details":"the type safe VoterClass for use within Solidity code","params":{"_class":"the address of the VoterClass contract"},"returns":{"_0":"Builder this contract"}},"withVoterClassAddress(address)":{"params":{"_classAddress":"the address of the VoterClass contract"},"returns":{"_0":"Builder this contract"}}},"title":"Governance Builder interface","version":1}
User Documentation
{"kind":"user","methods":{"aGovernance()":{"notice":"initialize and create a new builder context for this sender"},"build()":{"notice":"build the specified contract"},"name()":{"notice":"return the name of this implementation"},"version()":{"notice":"return the version of this implementation"},"withSupervisor(address)":{"notice":"add a supervisor to the supervisor list for the next constructed contract contract"},"withVoterClass(address)":{"notice":"set the VoterClass to be used for the next constructed contract"},"withVoterClassAddress(address)":{"notice":"set the VoterClass to be used for the next constructed contract"}},"notice":"Requirements for Governance Builder implementation","version":1}

======= contracts/CollectiveGovernance.sol:CollectiveGovernance =======
Developer Documentation
{"details":"The VoterClass is common to all proposed votes as are the project supervisors.   Individual supervisors may be configured as part of the proposal creation workflow but project supervisors are always included.","kind":"dev","methods":{"abstainFrom(uint256)":{"details":"auto discovery is attempted and if possible the method will proceed using the discovered shares","params":{"_proposalId":"The numeric id of the proposed vote"}},"abstainFrom(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"abstainFrom(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}},"configure(uint256,uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_quorumThreshold":"The threshold of participation that is required for a successful conclusion of voting","_requiredDuration":"The minimum time for voting to proceed before ending the vote is allowed"}},"endVote(uint256)":{"details":"it is not possible to end voting until the required duration has elapsed","params":{"_proposalId":"The numeric id of the proposed vote"}},"getStorageAddress()":{"returns":{"_0":"address The address of the store"}},"getVoteSucceeded(uint256)":{"details":"This method will fail if the vote was vetoed","returns":{"_0":"bool True if the vote is closed and passed"}},"isOpen(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"},"returns":{"_0":"bool True if the proposal is open"}},"name()":{"returns":{"_0":"string memory representation of name"}},"openVote(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"propose()":{"details":"Only one new proposal is allowed per msg.sender","returns":{"_0":"uint256 The id of the new proposal"}},"undoVote(uint256)":{"details":"Only applies to affirmative vote. auto discovery is attempted and if possible the method will proceed using the discovered shares","params":{"_proposalId":"The numeric id of the proposed vote"}},"undoVote(uint256,uint256)":{"details":"only applies to affirmative vote","params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"version()":{"returns":{"_0":"uint32 version number"}},"veto(uint256)":{"details":"transaction must be signed by a supervisor wallet","params":{"_proposalId":"The numeric id of the proposed vote"}},"voteAgainst(uint256)":{"details":"auto discovery is attempted and if possible the method will proceed using the discovered shares","params":{"_proposalId":"The numeric id of the proposed vote"}},"voteAgainst(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"voteAgainst(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}},"voteFor(uint256)":{"details":"Auto discovery is attempted and if possible the method will proceed using the discovered shares","params":{"_proposalId":"The numeric id of the proposed vote"}},"voteFor(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"voteFor(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}}},"title":"Collective Governance implementation","version":1}
User Documentation
{"events":{"ProposalClosed(uint256)":{"notice":"Voting is now closed for voting"},"ProposalCreated(address,uint256)":{"notice":"A new proposal was created"},"ProposalOpen(uint256)":{"notice":"The proposal is now open for voting"}},"kind":"user","methods":{"NAME()":{"notice":"contract name"},"abstainFrom(uint256)":{"notice":"abstain from vote by id"},"abstainFrom(uint256,uint256)":{"notice":"abstain from vote by id"},"abstainFrom(uint256,uint256[])":{"notice":"abstain from vote by id"},"configure(uint256,uint256,uint256)":{"notice":"configure an existing proposal by id"},"endVote(uint256)":{"notice":"end voting on an existing proposal by id"},"getStorageAddress()":{"notice":"return the address of the internal vote data store"},"getVoteSucceeded(uint256)":{"notice":"get the result of the vote"},"isOpen(uint256)":{"notice":"test if an existing proposal is open"},"name()":{"notice":"return the name of this implementation"},"openVote(uint256)":{"notice":"open an existing proposal by id"},"propose()":{"notice":"propose a vote for the community"},"supportsInterface(bytes4)":{"notice":"see ERC-165"},"undoVote(uint256)":{"notice":"undo any previous vote if any"},"undoVote(uint256,uint256)":{"notice":"undo any previous vote if any"},"version()":{"notice":"return the version of this implementation"},"veto(uint256)":{"notice":"veto proposal by id"},"voteAgainst(uint256)":{"notice":"cast an against vote by id"},"voteAgainst(uint256,uint256)":{"notice":"cast an against vote by id"},"voteAgainst(uint256,uint256[])":{"notice":"cast an against vote by id"},"voteFor(uint256)":{"notice":"cast an affirmative vote for the measure by id"},"voteFor(uint256,uint256)":{"notice":"cast an affirmative vote for the measure by id"},"voteFor(uint256,uint256[])":{"notice":"cast an affirmative vote for the measure by id"}},"notice":"Governance contract implementation for Collective.   This contract implements voting by groups of pooled voters, open voting or based on membership, such as class members who hold a specific ERC-721 token in their wallet. Creating a Vote is a three step process First, propose the vote.  Next, Configure the vote.  Finally, open the vote. Voting may proceed according to the conditions established during configuration.","version":1}

======= contracts/Governance.sol:Governance =======
Developer Documentation
{"kind":"dev","methods":{"configure(uint256,uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_quorumThreshold":"The threshold of participation that is required for a successful conclusion of voting","_requiredDuration":"The minimum time for voting to proceed before ending the vote is allowed"}},"getStorageAddress()":{"returns":{"_0":"address The address of the store"}},"name()":{"returns":{"_0":"string memory representation of name"}},"propose()":{"returns":{"_0":"uint256 The id of the new proposal"}},"version()":{"returns":{"_0":"uint32 version number"}}},"title":"Governance interface","version":1}
User Documentation
{"events":{"ProposalClosed(uint256)":{"notice":"Voting is now closed for voting"},"ProposalCreated(address,uint256)":{"notice":"A new proposal was created"},"ProposalOpen(uint256)":{"notice":"The proposal is now open for voting"}},"kind":"user","methods":{"configure(uint256,uint256,uint256)":{"notice":"configure an existing proposal by id"},"getStorageAddress()":{"notice":"return the address of the internal vote data store"},"name()":{"notice":"return the name of this implementation"},"propose()":{"notice":"propose a vote for the community"},"version()":{"notice":"return the version of this implementation"}},"notice":"Requirements for Governance implementation","version":1}

======= contracts/GovernanceBuilder.sol:GovernanceBuilder =======
Developer Documentation
{"kind":"dev","methods":{"aGovernance()":{"returns":{"_0":"Builder this contract"}},"build()":{"details":"contructs a new contract and may require a large gas fee, does not reinitialize context","returns":{"_0":"the address of the new Governance contract"}},"name()":{"returns":{"_0":"string memory representation of name"}},"version()":{"returns":{"_0":"uint32 version number"}},"withSupervisor(address)":{"details":"maintains an internal list which increases with every call","params":{"_supervisor":"the address of the wallet representing a supervisor for the project"},"returns":{"_0":"Builder this contract"}},"withVoterClass(address)":{"details":"the type safe VoterClass for use within Solidity code","params":{"_class":"the address of the VoterClass contract"},"returns":{"_0":"Builder this contract"}},"withVoterClassAddress(address)":{"params":{"_classAddress":"the address of the VoterClass contract"},"returns":{"_0":"Builder this contract"}}},"title":"Governance Builder implementation","version":1}
User Documentation
{"kind":"user","methods":{"aGovernance()":{"notice":"initialize and create a new builder context for this sender"},"build()":{"notice":"build the specified contract"},"name()":{"notice":"return the name of this implementation"},"version()":{"notice":"return the version of this implementation"},"withSupervisor(address)":{"notice":"add a supervisor to the supervisor list for the next constructed contract contract"},"withVoterClass(address)":{"notice":"set the VoterClass to be used for the next constructed contract"},"withVoterClassAddress(address)":{"notice":"set the VoterClass to be used for the next constructed contract"}},"notice":"This builder supports creating new instances of the Collective Governance Contract","version":1}

======= contracts/GovernanceStorage.sol:GovernanceStorage =======
Developer Documentation
{"details":"The creator of the contract, typically the Governance contract itself, privledged with respect to write opperations in this contract.   The creator is required for nearly all change operations","kind":"dev","methods":{"abstainForShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"abstentionCount(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number abstentions"}},"againstVotes(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number of against votes"}},"burnSupervisor(uint256,address,address)":{"details":"requires proposal creator","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_supervisor":"the supervisor address"}},"constructor":{"params":{"_class":"the contract that defines the popluation"}},"enableUndoVote(uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request"}},"endBlock(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the end block"}},"forVotes(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number of votes in favor"}},"getSender(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"address the address of the sender"}},"initializeProposal(address)":{"returns":{"_0":"uint256 the id of the proposal"}},"isFinal(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"bool true if the proposal is marked ready"}},"isSupervisor(uint256,address)":{"params":{"_proposalId":"the id of the proposal","_supervisor":"the address to check"},"returns":{"_0":"bool true if the address is a supervisor"}},"isVeto(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"bool true if the proposal is marked veto"}},"isVoter(uint256,address)":{"params":{"_proposalId":"the id of the proposal","_voter":"the address to check"},"returns":{"_0":"bool true if the address is a voter"}},"latestProposal(address)":{"returns":{"_0":"uint256 the id of the most recent proposal for sender"}},"makeFinal(uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request"}},"maxPassThreshold()":{"returns":{"_0":"uint256 the maximum value"}},"name()":{"returns":{"_0":"string memory representation of name"}},"quorum(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the amount of participation"}},"quorumRequired(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number required for quorum"}},"registerSupervisor(uint256,address,address)":{"details":"requires proposal creator","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_supervisor":"the supervisor address"}},"setQuorumThreshold(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_threshold":"the quorum number"}},"setRequiredVoteDuration(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_voteDuration":"the quorum number"}},"setVoteDelay(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_voteDelay":"the quorum number"}},"startBlock(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the start block"}},"undoVoteById(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_receiptId":"the id of the share to undo","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"validOrRevert(uint256)":{"params":{"_proposalId":"the id of the proposal"}},"version()":{"returns":{"_0":"uint32 version number"}},"veto(uint256,address)":{"details":"supervisor is required","params":{"_proposalId":"the id of the proposal","_sender":"the address of the veto sender"}},"voteAgainstByShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"voteDelay(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the delay"}},"voteDuration(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the duration"}},"voteForByShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"voteReceipt(uint256,uint256)":{"returns":{"_0":"_shareId the share id for the vote","_1":"_shareFor the shares cast in favor","_2":"_votesCast the number of votes cast","_3":"_isAbstention true if vote was an abstention","_4":"_isUndo true if the vote was reversed"}},"voterClass()":{"returns":{"_0":"VoterClass the voter class for this store"}}},"title":"GovernanceStorage implementation","version":1}
User Documentation
{"kind":"user","methods":{"NAME()":{"notice":"contract name"},"abstainForShare(uint256,address,uint256)":{"notice":"cast an abstention for the specified share"},"abstentionCount(uint256)":{"notice":"get the number of abstentions"},"againstVotes(uint256)":{"notice":"get the against vote count"},"burnSupervisor(uint256,address,address)":{"notice":"remove a supervisor from the proposal along with its ability to change or veto"},"constructor":{"notice":"create a new storage object with VoterClass as the voting population"},"enableUndoVote(uint256,address)":{"notice":"enable the undo feature for this vote"},"endBlock(uint256)":{"notice":"get the end block"},"forVotes(uint256)":{"notice":"get the for vote count"},"getSender(uint256)":{"notice":"get the address of the proposal sender"},"initializeProposal(address)":{"notice":"initialize a new proposal and return the id"},"isFinal(uint256)":{"notice":"test if proposal is ready or in the setup phase"},"isSupervisor(uint256,address)":{"notice":"test if the address is a supervisor on the specified proposal"},"isVeto(uint256)":{"notice":"test if proposal is veto"},"isVoter(uint256,address)":{"notice":"test if address is a voter on the specified proposal"},"latestProposal(address)":{"notice":"get the id of the last proposal for sender"},"makeFinal(uint256,address)":{"notice":"indicate the proposal is ready for voting and should be frozen"},"maxPassThreshold()":{"notice":"get the maxiumum possible for the pass threshold"},"name()":{"notice":"return the name of this implementation"},"proposalMap(uint256)":{"notice":"global list of proposed issues by id"},"quorum(uint256)":{"notice":"get the current number counting towards quorum"},"quorumRequired(uint256)":{"notice":"get the quorum required"},"registerSupervisor(uint256,address,address)":{"notice":"Register a new supervisor on the specified proposal. The supervisor has rights to add or remove voters prior to start of voting in a Voter Pool. The supervisor also has the right to veto the outcome of the vote."},"setQuorumThreshold(uint256,uint256,address)":{"notice":"set the minimum number of participants for a successful outcome"},"setRequiredVoteDuration(uint256,uint256,address)":{"notice":"set the required duration for the vote"},"setVoteDelay(uint256,uint256,address)":{"notice":"set the delay period required to preceed the vote"},"startBlock(uint256)":{"notice":"get the start block"},"undoVoteById(uint256,address,uint256)":{"notice":"undo vote for the specified receipt"},"validOrRevert(uint256)":{"notice":"do nothing or revert if the proposal is not valid"},"version()":{"notice":"return the version of this implementation"},"veto(uint256,address)":{"notice":"veto the specified proposal"},"voteAgainstByShare(uint256,address,uint256)":{"notice":"cast an against vote for the specified share"},"voteDelay(uint256)":{"notice":"get the vote delay"},"voteDuration(uint256)":{"notice":"get the vote duration"},"voteForByShare(uint256,address,uint256)":{"notice":"cast an affirmative vote for the specified share"},"voteReceipt(uint256,uint256)":{"notice":"get the vote receipt"},"voterClass()":{"notice":"get the VoterClass used for this voting store"}},"notice":"GovernanceStorage implements the necesscary infrastructure for governance and voting with safety controls","version":1}

======= contracts/Storage.sol:Storage =======
Developer Documentation
{"custom:type":"interface","kind":"dev","methods":{"abstainForShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"abstentionCount(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number abstentions"}},"againstVotes(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number of against votes"}},"burnSupervisor(uint256,address,address)":{"details":"requires proposal creator","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_supervisor":"the supervisor address"}},"enableUndoVote(uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request"}},"endBlock(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the end block"}},"forVotes(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number of votes in favor"}},"getSender(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"address the address of the sender"}},"initializeProposal(address)":{"returns":{"_0":"uint256 the id of the proposal"}},"isFinal(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"bool true if the proposal is marked ready"}},"isSupervisor(uint256,address)":{"params":{"_proposalId":"the id of the proposal","_supervisor":"the address to check"},"returns":{"_0":"bool true if the address is a supervisor"}},"isVeto(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"bool true if the proposal is marked veto"}},"isVoter(uint256,address)":{"params":{"_proposalId":"the id of the proposal","_voter":"the address to check"},"returns":{"_0":"bool true if the address is a voter"}},"latestProposal(address)":{"returns":{"_0":"uint256 the id of the most recent proposal for sender"}},"makeFinal(uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request"}},"maxPassThreshold()":{"returns":{"_0":"uint256 the maximum value"}},"name()":{"returns":{"_0":"string memory representation of name"}},"quorum(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the amount of participation"}},"quorumRequired(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the number required for quorum"}},"registerSupervisor(uint256,address,address)":{"details":"requires proposal creator","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_supervisor":"the supervisor address"}},"setQuorumThreshold(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_threshold":"the quorum number"}},"setRequiredVoteDuration(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_voteDuration":"the quorum number"}},"setVoteDelay(uint256,uint256,address)":{"details":"requires supervisor","params":{"_proposalId":"the id of the proposal","_sender":"original wallet for this request","_voteDelay":"the quorum number"}},"startBlock(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the start block"}},"undoVoteById(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_receiptId":"the id of the share to undo","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"validOrRevert(uint256)":{"params":{"_proposalId":"the id of the proposal"}},"version()":{"returns":{"_0":"uint32 version number"}},"veto(uint256,address)":{"details":"supervisor is required","params":{"_proposalId":"the id of the proposal","_sender":"the address of the veto sender"}},"voteAgainstByShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"voteDelay(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the delay"}},"voteDuration(uint256)":{"params":{"_proposalId":"the id of the proposal"},"returns":{"_0":"uint256 the duration"}},"voteForByShare(uint256,address,uint256)":{"params":{"_proposalId":"the id of the proposal","_shareId":"the id of the share","_wallet":"the wallet represented for the vote"},"returns":{"_0":"uint256 the number of votes cast"}},"voteReceipt(uint256,uint256)":{"returns":{"_isAbstention":"true if vote was an abstention","_isUndo":"true if the vote was reversed","_shareFor":"the shares cast in favor","_shareId":"the share id for the vote","_votesCast":"the number of votes cast"}},"voterClass()":{"returns":{"_0":"VoterClass the voter class for this store"}}},"title":"Storage interface","version":1}
User Documentation
{"kind":"user","methods":{"abstainForShare(uint256,address,uint256)":{"notice":"cast an abstention for the specified share"},"abstentionCount(uint256)":{"notice":"get the number of abstentions"},"againstVotes(uint256)":{"notice":"get the against vote count"},"burnSupervisor(uint256,address,address)":{"notice":"remove a supervisor from the proposal along with its ability to change or veto"},"enableUndoVote(uint256,address)":{"notice":"enable the undo feature for this vote"},"endBlock(uint256)":{"notice":"get the end block"},"forVotes(uint256)":{"notice":"get the for vote count"},"getSender(uint256)":{"notice":"get the address of the proposal sender"},"initializeProposal(address)":{"notice":"initialize a new proposal and return the id"},"isFinal(uint256)":{"notice":"test if proposal is ready or in the setup phase"},"isSupervisor(uint256,address)":{"notice":"test if the address is a supervisor on the specified proposal"},"isVeto(uint256)":{"notice":"test if proposal is veto"},"isVoter(uint256,address)":{"notice":"test if address is a voter on the specified proposal"},"latestProposal(address)":{"notice":"get the id of the last proposal for sender"},"makeFinal(uint256,address)":{"notice":"indicate the proposal is ready for voting and should be frozen"},"maxPassThreshold()":{"notice":"get the maxiumum possible for the pass threshold"},"name()":{"notice":"return the name of this implementation"},"quorum(uint256)":{"notice":"get the current number counting towards quorum"},"quorumRequired(uint256)":{"notice":"get the quorum required"},"registerSupervisor(uint256,address,address)":{"notice":"Register a new supervisor on the specified proposal. The supervisor has rights to add or remove voters prior to start of voting in a Voter Pool. The supervisor also has the right to veto the outcome of the vote."},"setQuorumThreshold(uint256,uint256,address)":{"notice":"set the minimum number of participants for a successful outcome"},"setRequiredVoteDuration(uint256,uint256,address)":{"notice":"set the required duration for the vote"},"setVoteDelay(uint256,uint256,address)":{"notice":"set the delay period required to preceed the vote"},"startBlock(uint256)":{"notice":"get the start block"},"undoVoteById(uint256,address,uint256)":{"notice":"undo vote for the specified receipt"},"validOrRevert(uint256)":{"notice":"do nothing or revert if the proposal is not valid"},"version()":{"notice":"return the version of this implementation"},"veto(uint256,address)":{"notice":"veto the specified proposal"},"voteAgainstByShare(uint256,address,uint256)":{"notice":"cast an against vote for the specified share"},"voteDelay(uint256)":{"notice":"get the vote delay"},"voteDuration(uint256)":{"notice":"get the vote duration"},"voteForByShare(uint256,address,uint256)":{"notice":"cast an affirmative vote for the specified share"},"voteReceipt(uint256,uint256)":{"notice":"get the vote receipt"},"voterClass()":{"notice":"get the VoterClass used for this voting store"}},"notice":"provides the requirements for Storage contract implementation","version":1}

======= contracts/VoteStrategy.sol:VoteStrategy =======
Developer Documentation
{"custom:type":"interface","kind":"dev","methods":{"abstainFrom(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"abstainFrom(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"abstainFrom(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}},"endVote(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"getVoteSucceeded(uint256)":{"details":"This method will fail if the vote was vetoed","returns":{"_0":"bool True if the vote is closed and passed"}},"isOpen(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"},"returns":{"_0":"bool True if the proposal is open"}},"openVote(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"undoVote(uint256)":{"details":"Only applies to affirmative vote.","params":{"_proposalId":"The numeric id of the proposed vote"}},"undoVote(uint256,uint256)":{"details":"only applies to affirmative vote","params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"veto(uint256)":{"details":"transaction must be signed by a supervisor wallet","params":{"_proposalId":"The numeric id of the proposed vote"}},"voteAgainst(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"voteAgainst(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"voteAgainst(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}},"voteFor(uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote"}},"voteFor(uint256,uint256)":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenId":"The id of a token or share representing the right to vote"}},"voteFor(uint256,uint256[])":{"params":{"_proposalId":"The numeric id of the proposed vote","_tokenIdList":"A array of tokens or shares that confer the right to vote"}}},"title":"VoteStrategy interface Requirements for voting implementations in Collective Governance","version":1}
User Documentation
{"kind":"user","methods":{"abstainFrom(uint256)":{"notice":"abstain from vote by id"},"abstainFrom(uint256,uint256)":{"notice":"abstain from vote by id"},"abstainFrom(uint256,uint256[])":{"notice":"abstain from vote by id"},"endVote(uint256)":{"notice":"end voting on an existing proposal by id"},"getVoteSucceeded(uint256)":{"notice":"get the result of the vote"},"isOpen(uint256)":{"notice":"test if an existing proposal is open"},"openVote(uint256)":{"notice":"open an existing proposal by id"},"undoVote(uint256)":{"notice":"undo any previous vote if any"},"undoVote(uint256,uint256)":{"notice":"undo any previous vote if any"},"veto(uint256)":{"notice":"veto proposal by id"},"voteAgainst(uint256)":{"notice":"cast an against vote by id"},"voteAgainst(uint256,uint256)":{"notice":"cast an against vote by id"},"voteAgainst(uint256,uint256[])":{"notice":"cast an against vote by id"},"voteFor(uint256)":{"notice":"cast an affirmative vote for the measure by id"},"voteFor(uint256,uint256)":{"notice":"cast an affirmative vote for the measure by id"},"voteFor(uint256,uint256[])":{"notice":"cast an affirmative vote for the measure by id"}},"version":1}

======= contracts/VoterClass.sol:VoterClass =======
Developer Documentation
{"custom:type":"interface","details":"The VoterClass is stateless and therefore does not require any special privledges.   It can be called by anyone.","kind":"dev","methods":{"confirm(address,uint256)":{"returns":{"_0":"uint256 The number of weighted votes confirmed"}},"discover(address)":{"returns":{"_0":"uint256[] array in memory of share ids"}},"isFinal()":{"details":"class must be final to be used in a Governance contract","returns":{"_0":"bool true if class is final"}},"isVoter(address)":{"returns":{"_0":"bool true if wallet is a voter"}},"name()":{"returns":{"_0":"string memory representation of name"}},"version()":{"returns":{"_0":"uint32 version number"}},"weight()":{"returns":{"_0":"uint256 weight applied to one share"}}},"title":"VoterClass interface","version":1}
User Documentation
{"kind":"user","methods":{"confirm(address,uint256)":{"notice":"confirm shareid is associated with wallet for voting"},"discover(address)":{"notice":"discover an array of shareIds associated with the specified wallet"},"isFinal()":{"notice":"test if voterclass is modifiable such as to add or remove voters from a pool"},"isVoter(address)":{"notice":"test if wallet represents an allowed voter for this class"},"name()":{"notice":"return the name of this implementation"},"version()":{"notice":"return the version of this implementation"},"weight()":{"notice":"return voting weight of each confirmed share"}},"notice":"The VoterClass interface defines the requirements for specifying a population or grouping of acceptable voting wallets","version":1}

======= contracts/VoterClassERC721.sol:VoterClassERC721 =======
Developer Documentation
{"details":"ERC721Enumerable is supported for discovery, however if the token contract does not support enumeration then vote by specific tokenId is still supported","kind":"dev","methods":{"confirm(address,uint256)":{"details":"does not require IERC721Enumerable, tokenId ownership is checked directly using ERC-721","returns":{"_0":"uint256 The number of weighted votes confirmed"}},"constructor":{"params":{"_contract":"Address of the token contract","_voteWeight":"The integral weight to apply to each token held by the wallet"}},"discover(address)":{"details":"discovery requires support for ERC721Enumerable, otherwise execution will revert","returns":{"_0":"uint256[] array in memory of share ids"}},"isFinal()":{"details":"always returns true","returns":{"_0":"bool true if final"}},"isVoter(address)":{"returns":{"_0":"bool true if wallet can sign for votes on this class"}},"name()":{"returns":{"_0":"string memory representation of name"}},"version()":{"returns":{"_0":"uint32 version number"}},"votesAvailable(address,uint256)":{"params":{"_tokenId":"The id of the token associated with the ERC-721 contract","_wallet":"The wallet to test for ownership"}},"weight()":{"returns":{"_0":"uint256 weight applied to one share"}}},"title":"ERC721 Implementation of VoterClass","version":1}
User Documentation
{"kind":"user","methods":{"confirm(address,uint256)":{"notice":"confirm tokenId is associated with wallet for voting"},"discover(address)":{"notice":"discover an array of tokenIds associated with the specified wallet"},"isFinal()":{"notice":"ERC-721 VoterClass is always final"},"isVoter(address)":{"notice":"determine if wallet holds at least one token from the ERC-721 contract"},"name()":{"notice":"return the name of this implementation"},"supportsInterface(bytes4)":{"notice":"see ERC-165"},"version()":{"notice":"return the version of this implementation"},"votesAvailable(address,uint256)":{"notice":"tabulate the number of votes available for the specific wallet and tokenId"},"weight()":{"notice":"return voting weight of each confirmed share"}},"notice":"This contract implements a voter pool based on ownership of an ERC-721 token. A class member is considered a voter if they have signing access to a wallet that is marked ownerOf a token of the specified address","version":1}

======= contracts/VoterClassFactory.sol:VoterClassFactory =======
Developer Documentation
{"kind":"dev","methods":{"createERC721(address,uint256)":{"params":{"_erc721":"The address of the ERC-721 contract for voting","_weight":"The weight associated with each vote"},"returns":{"_0":"address The address of the resulting voter class"}},"createOpenVote(uint256)":{"params":{"_weight":"The weight associated with each vote"},"returns":{"_0":"address The address of the resulting voter class"}},"createVoterPool(uint256)":{"params":{"_weight":"The weight associated with each vote"},"returns":{"_0":"address The address of the resulting voter class"}}},"title":"Creator for VoterClass implementations","version":1}
User Documentation
{"kind":"user","methods":{"createERC721(address,uint256)":{"notice":"create a VoterClass for token holding members"},"createOpenVote(uint256)":{"notice":"create a VoterClass for open voting"},"createVoterPool(uint256)":{"notice":"create a VoterClass for pooled voting"}},"notice":"A simple factory for VoterClass instances.","version":1}

======= contracts/VoterClassNullObject.sol:VoterClassNullObject =======
Developer Documentation
{"details":"No voter is allowed.","kind":"dev","methods":{"isFinal()":{"returns":{"_0":"bool always returns true"}},"isVoter(address)":{"returns":{"_0":"bool always returns false"}},"name()":{"returns":{"_0":"string memory representation of name"}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."},"version()":{"returns":{"_0":"uint32 version number"}}},"version":1}
User Documentation
{"kind":"user","methods":{"confirm(address,uint256)":{"notice":"always returns 0"},"discover(address)":{"notice":"always reverts"},"isFinal()":{"notice":"always final"},"isVoter(address)":{"notice":"no voter is allowed"},"name()":{"notice":"return the name of this implementation"},"version()":{"notice":"return the version of this implementation"},"weight()":{"notice":"always returns 0"}},"notice":"Null Object Pattern for VoterClass","version":1}

======= contracts/VoterClassOpenVote.sol:VoterClassOpenVote =======
Developer Documentation
{"kind":"dev","methods":{"confirm(address,uint256)":{"returns":{"_0":"uint256 The number of weighted votes confirmed"}},"constructor":{"params":{"_voteWeight":"The integral weight to apply to each token held by the wallet"}},"discover(address)":{"details":"the shareId of the open vote is the numeric value of the wallet address itself","returns":{"_0":"uint256[] array in memory of share ids"}},"isFinal()":{"details":"always returns true","returns":{"_0":"bool true if final"}},"isVoter(address)":{"details":"always returns true","returns":{"_0":"bool true if voter"}},"name()":{"returns":{"_0":"string memory representation of name"}},"version()":{"returns":{"_0":"uint32 version number"}},"weight()":{"returns":{"_0":"uint256 weight applied to one share"}}},"version":1}
User Documentation
{"kind":"user","methods":{"confirm(address,uint256)":{"notice":"confirm shareid is associated with wallet for voting"},"discover(address)":{"notice":"discover an array of shareIds associated with the specified wallet"},"isFinal()":{"notice":"OpenVote VoterClass is always final"},"isVoter(address)":{"notice":"return true for all wallets"},"name()":{"notice":"return the name of this implementation"},"supportsInterface(bytes4)":{"notice":"see ERC-165"},"version()":{"notice":"return the version of this implementation"},"weight()":{"notice":"return voting weight of each confirmed share"}},"notice":"OpenVote VoterClass allows every wallet to participate in an open vote","version":1}

======= contracts/VoterClassVoterPool.sol:VoterClassVoterPool =======
Developer Documentation
{"kind":"dev","methods":{"addVoter(address)":{"details":"only possible if not final","params":{"_wallet":"the address to add"}},"confirm(address,uint256)":{"returns":{"_0":"uint256 The number of weighted votes confirmed"}},"constructor":{"params":{"_voteWeight":"The integral weight to apply to each token held by the wallet"}},"discover(address)":{"returns":{"_0":"uint256[] array in memory of share ids"}},"isFinal()":{"returns":{"_0":"bool true if class is final"}},"isVoter(address)":{"returns":{"_0":"bool true if wallet is a voter"}},"name()":{"returns":{"_0":"string memory representation of name"}},"removeVoter(address)":{"details":"only possible if not final","params":{"_wallet":"the address to add"}},"version()":{"returns":{"_0":"uint32 version number"}}},"title":"VoterClassVoterPool contract","version":1}
User Documentation
{"kind":"user","methods":{"addVoter(address)":{"notice":"add a voter to the voter pool"},"confirm(address,uint256)":{"notice":"confirm shareid is associated with wallet for voting"},"discover(address)":{"notice":"discover an array of shareIds associated with the specified wallet"},"isFinal()":{"notice":"test if voterclass is modifiable such as to add or remove voters from a pool"},"isVoter(address)":{"notice":"test if wallet represents an allowed voter for this class"},"makeFinal()":{"notice":"set the voterpool final.   No further changes may be made to the voting pool."},"name()":{"notice":"return the name of this implementation"},"removeVoter(address)":{"notice":"remove a voter from the voter pool"},"supportsInterface(bytes4)":{"notice":"see ERC-165"},"version()":{"notice":"return the version of this implementation"},"weight()":{"notice":"return voting weight of each confirmed share"}},"notice":"This contract supports voting for a specific list of wallet addresses.   Each address must be added to the contract prior to voting at which time the pool must be marked as final so that it becomes impossible to modify","version":1}

======= contracts/VoterClassVoterPool.sol:VoterPool =======
Developer Documentation
{"custom:type":"interface","kind":"dev","methods":{"addVoter(address)":{"params":{"_wallet":"the address of the wallet"}},"isFinal()":{"returns":{"_0":"bool true if pool if final"}},"removeVoter(address)":{"params":{"_wallet":"the address of the wallet"}}},"title":"interface for VoterPool","version":1}
User Documentation
{"kind":"user","methods":{"addVoter(address)":{"notice":"add voter to pool"},"isFinal()":{"notice":"test if the pool if final"},"makeFinal()":{"notice":"mark the VoterPool as final"},"removeVoter(address)":{"notice":"remove voter from the pool"}},"notice":"sets the requirements for contracts implementing a VoterPool","version":1}
